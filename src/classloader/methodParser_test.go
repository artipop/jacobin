/*
 * Jacobin VM - A Java virtual machine
 * Copyright (c) 2021-2 by Andrew Binstock. All rights reserved.
 * Licensed under Mozilla Public License 2.0 (MPL 2.0)
 */

package classloader

import (
	"jacobin/src/globals"
	"jacobin/src/stringPool"
	"jacobin/src/trace"
	"strconv"
	"strings"
	"testing"
)

// test a valid Code attribute of a method
func TestValidCodeMethodAttribute(t *testing.T) {
	globals.InitGlobals("test")

	// variables we'll need.
	klass := ParsedClass{}
	klass.cpIndex = append(klass.cpIndex, cpEntry{})
	klass.cpIndex = append(klass.cpIndex, cpEntry{UTF8, 0})
	klass.cpIndex = append(klass.cpIndex, cpEntry{ClassRef, 0}) // points to classRef below
	klass.cpIndex = append(klass.cpIndex, cpEntry{UTF8, 2})

	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"Exceptions"})
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"java/io/IOException"}) // not used -- string pool instead

	name := "java/io/IOException"
	nameIndex := stringPool.GetStringIndex(&name)
	klass.classRefs = append(klass.classRefs, nameIndex) // classRef[0]

	klass.cpCount = 4

	// method
	meth := method{}
	meth.name = 2 // points to UTF8 entry: "testMethod"

	attrib := attr{}
	attrib.attrName = 1
	attrib.attrSize = 4
	attrib.attrContent = []byte{
		0, 4, // maxstack = 4
		0, 3, // maxlocals = 3
		0, 0, 0, 2, // code length = 2
		0x11, 0x16, // the two code bytes (randomly chosen)
		0, 0, // number of exceptions = 0 (exception handling is done elsewhere)
		0, 0, // attribute count of Code attribute (line number, etc.) = 0
	}

	err := parseCodeAttribute(attrib, &meth, &klass)
	if err != nil {
		t.Error("Unexpected error in processing valid Exceptions attribute of method")
	}

	if len(meth.codeAttr.code) != 2 {
		t.Error("Expected code length of 2. Got: " + strconv.Itoa(len(meth.codeAttr.code)))
	}

	if meth.codeAttr.maxStack != 4 {
		t.Error("Expected maxStack of 4. Got: " + strconv.Itoa(meth.codeAttr.maxStack))
	}

	if meth.codeAttr.maxLocals != 3 {
		t.Error("Expected maxLocals of 3. Got: " + strconv.Itoa(meth.codeAttr.maxLocals))
	}
	if len(meth.codeAttr.attributes) != 0 {
		t.Error("Expected 0 attributes of Code attribute. Got: " + strconv.Itoa(len(meth.codeAttr.attributes)))
	}
}

func Test1ValidMethodExceptionsAttribute(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	// variables we'll need.
	klass := ParsedClass{}
	klass.cpIndex = append(klass.cpIndex, cpEntry{})
	klass.cpIndex = append(klass.cpIndex, cpEntry{UTF8, 0})
	klass.cpIndex = append(klass.cpIndex, cpEntry{ClassRef, 0}) // points to classRef below
	klass.cpIndex = append(klass.cpIndex, cpEntry{UTF8, 2})

	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"Exceptions"})
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"java/io/IOException"}) // not used -- string pool instead

	name := "java/io/IOException"
	nameIndex := stringPool.GetStringIndex(&name)

	klass.classRefs = append(klass.classRefs, nameIndex) // classRef[0] points to stringPool entry for "java/io/IOException"

	klass.cpCount = 4

	// method
	meth := method{}
	meth.name = 2 // points to UTF8 entry: "testMethod"

	attrib := attr{}
	attrib.attrName = 1
	attrib.attrSize = 4
	attrib.attrContent = []byte{
		0, 1, // number of exceptions = 1
		0, 2, // points to 3rd CP entry, a classref that points to UTF8: java/io/IOException
	}

	err := parseExceptionsMethodAttribute(attrib, &meth, &klass)
	if err != nil {
		t.Error("Unexpected error in processing valid Exceptions attribute of method")
	}

	if klass.utf8Refs[2].content != name {
		t.Errorf("Expected %s but observed %s", name, klass.utf8Refs[2].content)
	}

	if len(meth.exceptions) != 1 {
		t.Error("In test of Exceptions method attribute, attribute was not added to method struct")
	}

	me := meth.exceptions[0]
	excName := stringPool.GetStringPointer(me)
	if *excName != name {
		t.Errorf("The wrong value for the UTF8 record on Exceptions method attribute was stored. Got: %s",
			*excName)
	}
}

// === the following tests were generated by JetBrains Junie to cover testing gaps

func TestParseMethods_InvalidAccessFlags(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.className = "TestClass"
	klass.methodCount = 1

	// Create incomplete byte data that will cause intFrom2Bytes to fail
	bytesToTest := []byte{0x01} // Only 1 byte, but intFrom2Bytes needs 2

	_, err := parseMethods(bytesToTest, 0, &klass)
	if err == nil {
		t.Error("Expected error for invalid access flags fetch")
	}
	if !strings.Contains(err.Error(), "Invalid fetch of method access flags in class: TestClass") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

func TestParseMethods_InvalidNameIndex(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.className = "TestClass"
	klass.methodCount = 1

	// Valid access flags but invalid name index
	bytesToTest := []byte{0x00, 0x01, 0x01} // Valid access flags, incomplete name index

	_, err := parseMethods(bytesToTest, 0, &klass)
	if err == nil {
		t.Error("Expected error for invalid name index fetch")
	}
	if !strings.Contains(err.Error(), "Invalid fetch of method name index in class: TestClass") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

/*
	func TestParseMethods_InvalidDescriptionIndex(t *testing.T) {
		globals.InitGlobals("test")
		trace.Init()

		klass := ParsedClass{}
		klass.className = "TestClass"
		klass.methodCount = 1

		// Valid access flags and name index but invalid description index
		bytesToTest := []byte{0x00, 0x01, 0x00, 0x01, 0x01} // Incomplete description index

		_, err := parseMethods(bytesToTest, 0, &klass)
		if err == nil {
			t.Error("Expected error for invalid description index fetch")
		}
		// Error should mention invalid UTF8 slot fetch
		if !strings.Contains(err.Error(), "Invalid fetch of method description index") {
			t.Errorf("Unexpected error message: %v", err)
		}
	}

	func TestParseMethods_InvalidUTF8Slot(t *testing.T) {
		globals.InitGlobals("test")
		trace.Init()

		klass := ParsedClass{}
		klass.className = "TestClass"
		klass.methodCount = 1
		klass.cpCount = 5
		klass.cpIndex = make([]cpEntry, 5)
		klass.cpIndex[1] = cpEntry{UTF8, 0}
		klass.cpIndex[2] = cpEntry{UTF8, 1}
		klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})
		klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"()V"})

		// Valid method structure but will fail on description slot fetch due to invalid index 3
		bytesToTest := []byte{
			0x00, 0x01, // access flags
			0x00, 0x01, // name index (valid)
			0x00, 0x03, // description index (points to non-existent CP entry)
			0x00, 0x00, // attribute count
		}

		_, err := parseMethods(bytesToTest, 0, &klass)
		if err == nil {
			t.Error("Expected error for invalid description slot fetch")
		}
		if !strings.Contains(err.Error(), "Invalid fetch of method description slot") {
			t.Errorf("Unexpected error message: %v", err)
		}
	}

	func TestParseMethods_InvalidAttributeCount(t *testing.T) {
		globals.InitGlobals("test")
		trace.Init()

		klass := ParsedClass{}
		klass.className = "TestClass"
		klass.methodCount = 1
		klass.cpCount = 3
		klass.cpIndex = make([]cpEntry, 3)
		klass.cpIndex[1] = cpEntry{UTF8, 0}
		klass.cpIndex[2] = cpEntry{UTF8, 1}
		klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})
		klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"()V"})

		// Valid method structure but incomplete attribute count
		bytesToTest := []byte{
			0x00, 0x01, // access flags
			0x00, 0x01, // name index
			0x00, 0x02, // description index
			0x00, // incomplete attribute count (needs 2 bytes)
		}

		_, err := parseMethods(bytesToTest, 0, &klass)
		if err == nil {
			t.Error("Expected error for invalid attribute count fetch")
		}
		if !strings.Contains(err.Error(), "Invalid fetch of method attribute count") {
			t.Errorf("Unexpected error message: %v", err)
		}
	}

	func TestParseMethods_AttributeFetchError(t *testing.T) {
		globals.InitGlobals("test")
		trace.Init()

		klass := ParsedClass{}
		klass.className = "TestClass"
		klass.methodCount = 1
		klass.cpCount = 3
		klass.cpIndex = make([]cpEntry, 3)
		klass.cpIndex[1] = cpEntry{UTF8, 0}
		klass.cpIndex[2] = cpEntry{UTF8, 1}
		klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})
		klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"()V"})

		// Valid method structure but attribute count > 0 with insufficient data
		bytesToTest := []byte{
			0x00, 0x01, // access flags
			0x00, 0x01, // name index
			0x00, 0x02, // description index
			0x00, 0x01, // attribute count = 1 (but no attribute data follows)
		}

		_, err := parseMethods(bytesToTest, 0, &klass)
		if err == nil {
			t.Error("Expected error for attribute fetch failure")
		}
		if !strings.Contains(err.Error(), "Error fetching method attribute") {
			t.Errorf("Unexpected error message: %v", err)
		}
	}
*/
func TestParseCodeAttribute_InvalidMaxStack(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.className = "TestClass"
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{0x00}, // Insufficient data for maxStack (needs 2 bytes)
	}

	err := parseCodeAttribute(attrib, &meth, &klass)
	if err == nil {
		t.Error("Expected error for invalid maxStack")
	}
	if !strings.Contains(err.Error(), "Error getting maxStack value in Code attribute") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

func TestParseCodeAttribute_InvalidMaxLocals(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.className = "TestClass"
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{0x00, 0x04, 0x00}, // Valid maxStack, incomplete maxLocals
	}

	err := parseCodeAttribute(attrib, &meth, &klass)
	if err == nil {
		t.Error("Expected error for invalid maxLocals")
	}
	if !strings.Contains(err.Error(), "Error getting maxLocals value in Code attribute") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

func TestParseCodeAttribute_InvalidCodeLength(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.className = "TestClass"
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{0x00, 0x04, 0x00, 0x03, 0x00, 0x00}, // Valid maxStack/maxLocals, incomplete code length
	}

	err := parseCodeAttribute(attrib, &meth, &klass)
	if err == nil {
		t.Error("Expected error for invalid code length")
	}
	if !strings.Contains(err.Error(), "Error getting code length in Code attribute") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

func TestParseCodeAttribute_InvalidExceptionCount(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.className = "TestClass"
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{
			0x00, 0x04, // maxStack
			0x00, 0x03, // maxLocals
			0x00, 0x00, 0x00, 0x02, // code length = 2
			0x11, 0x16, // code bytes
			0x00, // incomplete exception count
		},
	}

	err := parseCodeAttribute(attrib, &meth, &klass)
	if err == nil {
		t.Error("Expected error for invalid exception count")
	}
	if !strings.Contains(err.Error(), "Error getting count of exceptions in Code attribute") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

func TestParseCodeAttribute_InvalidCatchType(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.className = "TestClass"
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{
			0x00, 0x04, // maxStack
			0x00, 0x03, // maxLocals
			0x00, 0x00, 0x00, 0x02, // code length = 2
			0x11, 0x16, // code bytes
			0x00, 0x01, // exception count = 1
			0x00, 0x00, // startPc
			0x00, 0x02, // endPc
			0x00, 0x02, // handlerPc
			0x00, // incomplete catch type (needs 2 bytes)
		},
	}

	err := parseCodeAttribute(attrib, &meth, &klass)
	if err == nil {
		t.Error("Expected error for invalid catch type")
	}
	if !strings.Contains(err.Error(), "Error getting catch type for exception") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

func TestParseCodeAttribute_NonClassRefCatchType(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.className = "TestClass"
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})
	klass.cpIndex = make([]cpEntry, 3)
	klass.cpIndex[1] = cpEntry{UTF8, 0} // Not a ClassRef

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{
			0x00, 0x04, // maxStack
			0x00, 0x03, // maxLocals
			0x00, 0x00, 0x00, 0x02, // code length = 2
			0x11, 0x16, // code bytes
			0x00, 0x01, // exception count = 1
			0x00, 0x00, // startPc
			0x00, 0x02, // endPc
			0x00, 0x02, // handlerPc
			0x00, 0x01, // catch type (points to non-ClassRef)
			0x00, 0x00, // attribute count
		},
	}

	err := parseCodeAttribute(attrib, &meth, &klass)
	if err == nil {
		t.Error("Expected error for non-ClassRef catch type")
	}
	if !strings.Contains(err.Error(), "Invalid catchType in method testMethod") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

func TestParseCodeAttribute_InvalidAttributeCount(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.className = "TestClass"
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{
			0x00, 0x04, // maxStack
			0x00, 0x03, // maxLocals
			0x00, 0x00, 0x00, 0x02, // code length = 2
			0x11, 0x16, // code bytes
			0x00, 0x00, // exception count = 0
			0x00, // incomplete attribute count
		},
	}

	err := parseCodeAttribute(attrib, &meth, &klass)
	if err == nil {
		t.Error("Expected error for invalid attribute count")
	}
	if !strings.Contains(err.Error(), "Error getting attributes in Code attribute") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

func TestParseCodeAttribute_SubAttributeError(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.className = "TestClass"
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{
			0x00, 0x04, // maxStack
			0x00, 0x03, // maxLocals
			0x00, 0x00, 0x00, 0x02, // code length = 2
			0x11, 0x16, // code bytes
			0x00, 0x00, // exception count = 0
			0x00, 0x01, // attribute count = 1 (but no attribute data)
		},
	}

	err := parseCodeAttribute(attrib, &meth, &klass)
	if err == nil {
		t.Error("Expected error for sub-attribute fetch failure")
	}
	if !strings.Contains(err.Error(), "Error retrieving attributes in Code attribute") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

func TestBuildLineNumberTable_ZeroEntryCount(t *testing.T) {
	codeAttr := codeAttrib{}
	attr := attr{
		attrContent: []byte{0x00, 0x00}, // entry count = 0
	}

	buildLineNumberTable(&codeAttr, &attr, "testMethod")

	if codeAttr.sourceLineTable != nil {
		t.Error("Expected sourceLineTable to be nil for zero entry count")
	}
}

func TestBuildLineNumberTable_SingleEntry(t *testing.T) {
	codeAttr := codeAttrib{}
	attr := attr{
		attrContent: []byte{
			0x00, 0x01, // entry count = 1
			0x00, 0x00, // bytecode position = 0
			0x00, 0x05, // source line = 5
		},
	}

	buildLineNumberTable(&codeAttr, &attr, "testMethod")

	if codeAttr.sourceLineTable == nil {
		t.Error("Expected sourceLineTable to be created")
	}

	table := *codeAttr.sourceLineTable
	if len(table) != 1 {
		t.Errorf("Expected 1 entry in line number table, got %d", len(table))
	}

	if table[0].BytecodePos != 0 || table[0].SourceLine != 5 {
		t.Errorf("Expected bytecode pos 0, source line 5, got pos %d, line %d",
			table[0].BytecodePos, table[0].SourceLine)
	}
}

func TestBuildLineNumberTable_MultipleEntriesSorted(t *testing.T) {
	codeAttr := codeAttrib{}
	attr := attr{
		attrContent: []byte{
			0x00, 0x03, // entry count = 3
			0x00, 0x08, // bytecode position = 8
			0x00, 0x15, // source line = 21
			0x00, 0x00, // bytecode position = 0
			0x00, 0x10, // source line = 16
			0x00, 0x04, // bytecode position = 4
			0x00, 0x12, // source line = 18
		},
	}

	buildLineNumberTable(&codeAttr, &attr, "testMethod")

	if codeAttr.sourceLineTable == nil {
		t.Error("Expected sourceLineTable to be created")
	}

	table := *codeAttr.sourceLineTable
	if len(table) != 3 {
		t.Errorf("Expected 3 entries in line number table, got %d", len(table))
	}

	// Check that entries are sorted by bytecode position
	if table[0].BytecodePos != 0 || table[1].BytecodePos != 4 || table[2].BytecodePos != 8 {
		t.Error("Line number table entries are not properly sorted by bytecode position")
	}
}

func TestBuildLineNumberTable_ExistingTable(t *testing.T) {
	existingTable := []BytecodeToSourceLine{{0, 1}}
	codeAttr := codeAttrib{sourceLineTable: &existingTable}

	attr := attr{
		attrContent: []byte{
			0x00, 0x01, // entry count = 1
			0x00, 0x04, // bytecode position = 4
			0x00, 0x10, // source line = 16
		},
	}

	buildLineNumberTable(&codeAttr, &attr, "testMethod")

	table := *codeAttr.sourceLineTable
	if len(table) != 1 {
		t.Errorf("Expected existing table to be replaced with 1 entry, got %d", len(table))
	}

	if table[0].BytecodePos != 4 || table[0].SourceLine != 16 {
		t.Errorf("Expected bytecode pos 4, source line 16, got pos %d, line %d",
			table[0].BytecodePos, table[0].SourceLine)
	}
}

func TestB2sTable_SortFunctions(t *testing.T) {
	table := b2sTable{
		{BytecodePos: 8, SourceLine: 21},
		{BytecodePos: 0, SourceLine: 16},
		{BytecodePos: 4, SourceLine: 18},
	}

	// Test Len
	if table.Len() != 3 {
		t.Errorf("Expected length 3, got %d", table.Len())
	}

	// Test Less
	if !table.Less(1, 0) { // pos 0 < pos 8
		t.Error("Less function not working correctly")
	}

	// Test Swap
	table.Swap(0, 1)
	if table[0].BytecodePos != 0 || table[1].BytecodePos != 8 {
		t.Error("Swap function not working correctly")
	}
}

func TestParseExceptionsMethodAttribute_InvalidExceptionCount(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{0x00}, // Incomplete exception count (needs 2 bytes)
	}

	err := parseExceptionsMethodAttribute(attrib, &meth, &klass)
	if err == nil {
		t.Error("Expected error for invalid exception count")
	}
	if !strings.Contains(err.Error(), "Error retrieving exception count in method testMethod") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

func TestParseExceptionsMethodAttribute_NonClassRefException(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})
	klass.cpIndex = make([]cpEntry, 3)
	klass.cpIndex[1] = cpEntry{UTF8, 0} // Not a ClassRef

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{
			0x00, 0x01, // exception count = 1
			0x00, 0x01, // exception index (points to non-ClassRef)
		},
	}

	err := parseExceptionsMethodAttribute(attrib, &meth, &klass)
	if err == nil {
		t.Error("Expected error for non-ClassRef exception")
	}
	if !strings.Contains(err.Error(), "does not point to a ClassRef CP entry") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

func TestParseExceptionsMethodAttribute_InvalidStringPoolEntry(t *testing.T) {
	globals.InitGlobals("test")
	globals.InitStringPool()
	trace.Init()

	klass := ParsedClass{}
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})
	klass.cpIndex = make([]cpEntry, 3)
	klass.cpIndex[1] = cpEntry{ClassRef, 0}
	klass.classRefs = []uint32{999999} // Invalid string pool index

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{
			0x00, 0x01, // exception count = 1
			0x00, 0x01, // exception index
		},
	}

	err := parseExceptionsMethodAttribute(attrib, &meth, &klass)
	if err == nil {
		t.Error("Expected error for invalid string pool entry")
	}
	if !strings.Contains(err.Error(), "does not point to a valid stringPool entry") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

func TestParseMethodParametersAttribute_InvalidNameIndex(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{
			0x01, // parameters count = 1
			0x00, // incomplete name index (needs 2 bytes)
		},
	}

	err := parseMethodParametersAttribute(attrib, &meth, &klass)
	if err == nil {
		t.Error("Expected error for invalid name index")
	}
	if !strings.Contains(err.Error(), "Error getting name index for MethodParameters attribute") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

func TestParseMethodParametersAttribute_InvalidUTF8Fetch(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})
	klass.cpCount = 2
	klass.cpIndex = make([]cpEntry, 2)

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{
			0x01,       // parameters count = 1
			0x00, 0x01, // name index = 1 (but no valid UTF8 entry)
			0x00, 0x00, // access flags
		},
	}

	err := parseMethodParametersAttribute(attrib, &meth, &klass)
	if err == nil {
		t.Error("Expected error for invalid UTF8 fetch")
	}
	if !strings.Contains(err.Error(), "Error getting name of MethodParameters attribute") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

func TestParseMethodParametersAttribute_InvalidAccessFlags(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{
			0x01,       // parameters count = 1
			0x00, 0x00, // name index = 0 (empty name)
			0x00, // incomplete access flags (needs 2 bytes)
		},
	}

	err := parseMethodParametersAttribute(attrib, &meth, &klass)
	if err == nil {
		t.Error("Expected error for invalid access flags")
	}
	if !strings.Contains(err.Error(), "Error getting access flags of MethodParameters attribute") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

func TestParseMethodParametersAttribute_InvalidAccessFlagsValue(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{
			0x01,       // parameters count = 1
			0x00, 0x00, // name index = 0 (empty name)
			0x00, 0x01, // invalid access flags value
		},
	}

	err := parseMethodParametersAttribute(attrib, &meth, &klass)
	if err == nil {
		t.Error("Expected error for invalid access flags value")
	}
	if !strings.Contains(err.Error(), "Invalid access flags of MethodParameters attribute") {
		t.Errorf("Unexpected error message: %v", err)
	}
}

func TestParseMethodParametersAttribute_ValidAccessFlags(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"paramName"})
	klass.cpCount = 3
	klass.cpIndex = make([]cpEntry, 3)
	klass.cpIndex[1] = cpEntry{UTF8, 1}

	validFlags := []int{0x00, 0x10, 0x1000, 0x1010, 0x8000, 0x8010}

	for _, flags := range validFlags {
		meth := method{name: 0}
		attrib := attr{
			attrContent: []byte{
				0x01,       // parameters count = 1
				0x00, 0x01, // name index = 1
				byte(flags >> 8), byte(flags), // access flags
			},
		}

		err := parseMethodParametersAttribute(attrib, &meth, &klass)
		if err != nil {
			t.Errorf("Unexpected error for valid access flags 0x%04X: %v", flags, err)
		}

		if len(meth.parameters) != 1 {
			t.Errorf("Expected 1 parameter, got %d", len(meth.parameters))
		}

		if meth.parameters[0].accessFlags != flags {
			t.Errorf("Expected access flags 0x%04X, got 0x%04X", flags, meth.parameters[0].accessFlags)
		}
	}
}

func TestParseMethodParametersAttribute_EmptyParameterName(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{
			0x01,       // parameters count = 1
			0x00, 0x00, // name index = 0 (indicates empty name)
			0x00, 0x00, // access flags = 0
		},
	}

	err := parseMethodParametersAttribute(attrib, &meth, &klass)
	if err != nil {
		t.Errorf("Unexpected error for empty parameter name: %v", err)
	}

	if len(meth.parameters) != 1 {
		t.Errorf("Expected 1 parameter, got %d", len(meth.parameters))
	}

	if meth.parameters[0].name != "" {
		t.Errorf("Expected empty parameter name, got %q", meth.parameters[0].name)
	}
}

/*
func TestParseMethodParametersAttribute_MultipleParameters(t *testing.T) {
	globals.InitGlobals("test")
	trace.Init()

	klass := ParsedClass{}
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"testMethod"})
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"param1"})
	klass.utf8Refs = append(klass.utf8Refs, utf8Entry{"param2"})
	klass.cpCount = 4
	klass.cpIndex = make([]cpEntry, 4)
	klass.cpIndex[1] = cpEntry{UTF8, 1}
	klass.cpIndex[2] = cpEntry{UTF8, 2}

	meth := method{name: 0}
	attrib := attr{
		attrContent: []byte{
			0x02,       // parameters count = 2
			0x00, 0x01, // name index = 1
			0x00, 0x10, // access flags = 0x10
			0x00, 0x02, // name index = 2
			0x10, 0x00, // access flags = 0x1000
		},
	}

	err := parseMethodParametersAttribute(attrib, &meth, &klass)
	if err != nil {
		t.Errorf("Unexpected error for multiple parameters: %v", err)
	}

	if len(meth.parameters) != 2 {
		t.Errorf("Expected 2 parameters, got %d", len(meth.parameters))
	}

	if meth.parameters[0].name != "param1" || meth.parameters[1].name != "param2" {
		t.Errorf("Parameter names not correctly set: got %q, %q",
			meth.parameters[0].name, meth.parameters[1].name)
	}

	if meth.parameters[0].accessFlags != 0x10 || meth.parameters[1].accessFlags != 0x1000 {
		t.Errorf("Access flags not correctly set: got 0x%04X, 0x%04X",
			meth.parameters[0].accessFlags, meth.parameters[1].accessFlags)
	}
}
*/
// === end of tests generated by JetBrains Junie ===
