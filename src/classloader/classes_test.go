/*
 * Jacobin VM - A Java virtual machine
 * Copyright (c) 2021-2 by the Jacobin authors. All rights reserved.
 * Licensed under Mozilla Public License 2.0 (MPL 2.0)
 */
package classloader

import (
	"io"
	"jacobin/globals"
	"jacobin/stringPool"
	"jacobin/types"
	"os"
	"strings"
	"sync"
	"testing"
)

func TestFetchUTF8stringFromCPEntryNumber(t *testing.T) {
	// redirect stderr & stdout to capture results from stderr
	normalStderr := os.Stderr
	_, w, _ := os.Pipe()
	os.Stderr = w

	normalStdout := os.Stdout
	_, wout, _ := os.Pipe()
	os.Stdout = wout

	cp := CPool{}

	cp.CpIndex = append(cp.CpIndex, CpEntry{})
	cp.CpIndex = append(cp.CpIndex, CpEntry{UTF8, 0})
	cp.CpIndex = append(cp.CpIndex, CpEntry{ClassRef, 0}) // points to classRef below, which points to the next CP entry
	cp.CpIndex = append(cp.CpIndex, CpEntry{UTF8, 2})

	cp.Utf8Refs = append(cp.Utf8Refs, "Exceptions")
	cp.Utf8Refs = append(cp.Utf8Refs, "testMethod")
	cp.Utf8Refs = append(cp.Utf8Refs, "java/io/IOException")

	s := FetchUTF8stringFromCPEntryNumber(&cp, 0) // invalid CP entry
	if s != "" {
		t.Error("Unexpected result in call to FetchUTF8stringFromCPEntryNumber()")
	}

	s = FetchUTF8stringFromCPEntryNumber(&cp, 1)
	if s != "Exceptions" {
		t.Error("Unexpected result in call to FetchUTF8stringFromCPEntryNumber()")
	}

	s = FetchUTF8stringFromCPEntryNumber(&cp, 2) // not UTF8, so should be an error
	if s != "" {
		t.Error("Unexpected result in call to FetchUTF8stringFromCPEntryNumber()")
	}

	_ = w.Close()
	os.Stderr = normalStderr

	_ = wout.Close()
	os.Stdout = normalStdout
}

func TestInvalidMainMethod(t *testing.T) {
	// Testing the changes made as a result of JACOBIN-103
	globals.InitGlobals("test")

	// redirect stderr & stdout to capture results from stderr
	normalStderr := os.Stderr
	_, w, _ := os.Pipe()
	os.Stderr = w

	MethArea = &sync.Map{}
	k := Klass{
		Status: 0,
		Loader: "",
		Data:   &ClData{},
	}
	k.Data.Name = "testClass"
	k.Data.SuperclassIndex = types.ObjectPoolStringIndex
	k.Loader = "testloader"
	k.Status = 'F'
	MethAreaInsert("TestEntry", &k)

	// we need a java/lang/Object instance, so just duplicate the entry
	// in the MethArea. It's only a placeholder
	MethAreaInsert(types.ObjectClassName, &k)

	// fetch a non-existent main() method
	_, err := FetchMethodAndCP("java/lan/Object", "main", "([LString;)V")
	if err == nil {
		t.Errorf("Expecting an err msg for invalid MethAreaFetch of main(), but got none")
	}

	msg := err.Error()
	if !strings.Contains(msg, "main() method not found") {
		t.Errorf("TestInvalidLookupOfMethod: Expecting error of 'main() method not found', got %s", err.Error())
	}

	// restore stderr and stdout to what they were before
	_ = w.Close()
	os.Stderr = normalStderr
}

func TestInvalidClassName(t *testing.T) {
	globals.InitGlobals("test")

	// redirect stderr & stdout to capture results from stderr
	normalStderr := os.Stderr
	_, w, _ := os.Pipe()
	os.Stderr = w

	MethArea = &sync.Map{}

	// fetch a non-existent method in a non-existent class
	_, err := FetchMethodAndCP("gherkin", "mcMurtry", "([LString;)V")
	if err == nil {
		t.Errorf("Expecting an err msg for invalid MethAreaFetch of main(), but got none")
	}

	msg := err.Error()
	if !strings.HasPrefix(msg, "FetchMethodAndCP: LoadClassFromNameOnly for gherkin failed") {
		t.Errorf("TestInvalidClassName: Did not get expected error message', got %s", err.Error())
	}

	// restore stderr and stdout to what they were before
	_ = w.Close()
	os.Stderr = normalStderr
}

// === Following tests are generated by Junie to cover remaining untested execution paths ===

// Helper to reset global structures that tests rely on and keep isolation between tests.
func resetState() {
	MTable = make(MT)
	MethArea = &sync.Map{}
}

func TestFetchMethodAndCP_MTableHit_J(t *testing.T) {
	globals.InitGlobals("test")
	resetState()

	// Ensure class is considered loaded so FetchMethodAndCP wonâ€™t try to load it
	klassName := "com/example/Foo"
	MethAreaInsert(klassName, &Klass{Status: 'F', Data: &ClData{}})

	// Insert an entry in MTable with MType 'J'
	fqn := klassName + ".bar" + "()V"
	jm := JmEntry{MaxStack: 1, MaxLocals: 1, Code: []byte{}} // non-nil method
	AddEntry(&MTable, fqn, MTentry{Meth: jm, MType: 'J'})

	res, err := FetchMethodAndCP(klassName, "bar", "()V")
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if res.MType != 'J' {
		t.Fatalf("expected MType 'J', got %q", res.MType)
	}
}

func TestFetchMethodAndCP_MTableHit_G(t *testing.T) {
	globals.InitGlobals("test")
	resetState()

	klassName := "com/example/Foo"
	MethAreaInsert(klassName, &Klass{Status: 'F', Data: &ClData{}})

	// Insert a Go/native method entry
	fqn := klassName + ".baz" + "(I)I"
	gm := Function(func(args []interface{}) interface{} { return 42 })
	AddEntry(&MTable, fqn, MTentry{Meth: gm, MType: 'G'})

	res, err := FetchMethodAndCP(klassName, "baz", "(I)I")
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if res.MType != 'G' {
		t.Fatalf("expected MType 'G', got %q", res.MType)
	}
}

func TestFetchMethodAndCP_MTableHit_InvalidType(t *testing.T) {
	globals.InitGlobals("test")
	resetState()

	klassName := "com/example/Foo"
	MethAreaInsert(klassName, &Klass{Status: 'F', Data: &ClData{}})

	fqn := klassName + ".qux" + "()V"
	jm := JmEntry{MaxStack: 1, MaxLocals: 1}
	AddEntry(&MTable, fqn, MTentry{Meth: jm, MType: 'X'})

	// Capture stderr for the error message (FetchMethodAndCP logs and returns an error)
	normalStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	_, err := FetchMethodAndCP(klassName, "qux", "()V")
	_ = w.Close()
	msg, _ := io.ReadAll(r)
	os.Stderr = normalStderr

	if err == nil {
		t.Fatalf("expected error for invalid MType, got none")
	}
	errMsg := string(msg)
	if !strings.Contains(errMsg, "methEntry.MType is neither J nor G") {
		t.Fatalf("unexpected stderr: %s", errMsg)
	}
}

func TestFetchMethodAndCP_WaitForClassStatusError(t *testing.T) {
	globals.InitGlobals("test")
	resetState()

	klassName := "com/example/Unstable"
	// Insert class with Status 'I' so WaitForClassStatus() times out
	MethAreaInsert(klassName, &Klass{Status: 'I', Data: &ClData{}})

	// Capture stderr
	normalStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	_, err := FetchMethodAndCP(klassName, "m", "()V")
	_ = w.Close()
	_, _ = io.ReadAll(r)
	os.Stderr = normalStderr

	if err == nil {
		t.Fatalf("expected WaitForClassStatus error, got nil")
	}
	if !strings.Contains(err.Error(), "WaitClassStatus: Timeout") {
		t.Fatalf("unexpected error: %v", err)
	}
}

func TestFetchMethodAndCP_FoundInClassMethodTable(t *testing.T) {
	globals.InitGlobals("test")
	resetState()

	klassName := "com/example/Owner"
	// Build a class whose MethodTable contains the method
	cp := CPool{}
	kData := &ClData{
		Name:        klassName,
		MethodTable: make(map[string]*Method),
		CP:          cp,
	}
	meth := &Method{AccessFlags: 0x1, CodeAttr: CodeAttrib{MaxStack: 2, MaxLocals: 1, Code: []byte{0xb1}}}
	kData.MethodTable["doIt()V"] = meth
	MethAreaInsert(klassName, &Klass{Status: 'F', Data: kData})

	res, err := FetchMethodAndCP(klassName, "doIt", "()V")
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if res.MType != 'J' {
		t.Fatalf("expected 'J' for Java method, got %q", res.MType)
	}
	// Verify MTable got populated for quick lookups next time
	fqn := klassName + ".doIt()V"
	if _, ok := MTable[fqn]; !ok {
		t.Fatalf("expected MTable to contain %s", fqn)
	}
}

func TestFetchMethodAndCP_MainMissingWhenClassLoaded(t *testing.T) {
	globals.InitGlobals("test")
	resetState()

	klassName := "com/example/NoMain"
	kData := &ClData{Name: klassName, MethodTable: make(map[string]*Method)}
	MethAreaInsert(klassName, &Klass{Status: 'F', Data: kData})

	// Capture stderr because noMainError logs and triggers a controlled exit in test mode
	normalStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	_, err := FetchMethodAndCP(klassName, "main", "([Ljava/lang/String;)V")
	_ = w.Close()
	_, _ = io.ReadAll(r)
	os.Stderr = normalStderr

	if err == nil {
		t.Fatalf("expected error when main() not found in loaded class, got nil")
	}
	if !strings.Contains(err.Error(), "main() not found") {
		t.Fatalf("unexpected error: %v", err)
	}
}

func TestFetchMethodAndCP_SuperclassFound(t *testing.T) {
	globals.InitGlobals("test")
	resetState()

	// Prepare string pool entries for class names
	superName := "com/example/Super"
	subName := "com/example/Sub"
	superIdx := stringPool.GetStringIndex(&superName)

	// Superclass with the method in its MethodTable
	superData := &ClData{Name: superName, MethodTable: make(map[string]*Method), CP: CPool{}}
	superData.MethodTable["work()V"] = &Method{CodeAttr: CodeAttrib{MaxStack: 1, MaxLocals: 0, Code: []byte{0xb1}}}
	MethAreaInsert(superName, &Klass{Status: 'F', Data: superData})

	// Subclass pointing to the superclass
	subData := &ClData{Name: subName, SuperclassIndex: superIdx, MethodTable: make(map[string]*Method), CP: CPool{}}
	MethAreaInsert(subName, &Klass{Status: 'F', Data: subData})

	res, err := FetchMethodAndCP(subName, "work", "()V")
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if res.MType != 'J' {
		t.Fatalf("expected 'J', got %q", res.MType)
	}
	// Ensure the entry is stored under the subclass FQN as per implementation
	fqn := subName + ".work()V"
	if _, ok := MTable[fqn]; !ok {
		t.Fatalf("expected MTable to contain %s", fqn)
	}
}

func TestFetchMethodAndCP_SuperclassFetchNilError(t *testing.T) {
	globals.InitGlobals("test")
	resetState()

	missingSuper := "com/example/MissingSuper"
	child := "com/example/Child"
	missingIdx := stringPool.GetStringIndex(&missingSuper)

	childData := &ClData{Name: child, SuperclassIndex: missingIdx, MethodTable: make(map[string]*Method)}
	MethAreaInsert(child, &Klass{Status: 'F', Data: childData})

	// Capture stderr for the error message
	normalStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	_, err := FetchMethodAndCP(child, "x", "()V")
	_ = w.Close()
	_, _ = io.ReadAll(r)
	os.Stderr = normalStderr

	if err == nil {
		t.Fatalf("expected error due to missing superclass entry, got nil")
	}
	if !strings.Contains(err.Error(), "could not find superclass") {
		t.Fatalf("unexpected error: %v", err)
	}
}

func TestFetchMethodAndCP_SuperclassesExhausted_NoMethod(t *testing.T) {
	globals.InitGlobals("test")
	resetState()

	// Ensure java/lang/Object exists with no target method
	objName := types.ObjectClassName
	objData := &ClData{Name: objName, MethodTable: make(map[string]*Method)}
	MethAreaInsert(objName, &Klass{Status: 'F', Data: objData})

	midName := "com/example/Mid"
	subName := "com/example/Sub2"
	objIdx := types.ObjectPoolStringIndex
	midIdx := stringPool.GetStringIndex(&midName)

	midData := &ClData{Name: midName, SuperclassIndex: objIdx, MethodTable: make(map[string]*Method)}
	MethAreaInsert(midName, &Klass{Status: 'F', Data: midData})

	subData := &ClData{Name: subName, SuperclassIndex: midIdx, MethodTable: make(map[string]*Method)}
	MethAreaInsert(subName, &Klass{Status: 'F', Data: subData})

	_, err := FetchMethodAndCP(subName, "nope", "()V")
	if err == nil {
		t.Fatalf("expected error when no superclass contains method, got nil")
	}
	if !strings.Contains(err.Error(), "Neither "+subName+" nor its superclasses contain method nope") {
		t.Fatalf("unexpected error: %v", err)
	}
}

func TestFetchUTF8stringFromCPEntryNumber_UpperBoundOutOfRange(t *testing.T) {
	cp := CPool{}
	cp.CpIndex = make([]CpEntry, 3) // valid entries are 0..2, but function expects 1..(len-1)
	// Place a valid UTF8 at index 1 to ensure table is plausible
	cp.CpIndex[1] = CpEntry{Type: UTF8, Slot: 0}
	cp.Utf8Refs = []string{"hello"}

	// entry == len(cp.CpIndex) should be out of bounds
	normalStderr := os.Stderr
	r, w, _ := os.Pipe()
	os.Stderr = w

	s := FetchUTF8stringFromCPEntryNumber(&cp, uint16(len(cp.CpIndex)))
	_ = w.Close()
	_, _ = io.ReadAll(r)
	os.Stderr = normalStderr

	if s != "" {
		t.Fatalf("expected empty string for out-of-range entry, got %q", s)
	}
}
